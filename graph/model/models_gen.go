// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package model

import (
	"fmt"
	"io"
	"strconv"
	"time"
)

type Birthday struct {
	Month int `json:"month"`
	Day   int `json:"day"`
	Year  int `json:"year"`
}

type Cents struct {
	Total     int `json:"total"`
	Deposited int `json:"deposited"`
	Earned    int `json:"earned"`
	Given     int `json:"given"`
}

type Channel struct {
	ID       string    `json:"id"`
	Members  []*User   `json:"members,omitempty"`
	Messages *Messages `json:"messages,omitempty"`
}

type Comment struct {
	Post      *Post      `json:"post,omitempty"`
	Content   string     `json:"content"`
	Commenter *User      `json:"commenter,omitempty"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
}

type CommentCreateInput struct {
	Content     *string      `json:"content,omitempty"`
	ContentType *ContentType `json:"contentType,omitempty"`
}

type Comments struct {
	Comments []*Comment `json:"comments"`
	Next     string     `json:"next"`
}

type Like struct {
	Post      *Post      `json:"post,omitempty"`
	Liker     *User      `json:"liker,omitempty"`
	CreatedAt *time.Time `json:"createdAt,omitempty"`
}

type Likes struct {
	Likes []*Like `json:"likes"`
	Next  string  `json:"next"`
}

type Message struct {
	Content     *string      `json:"content,omitempty"`
	ContentType *ContentType `json:"contentType,omitempty"`
	CreatedAt   *time.Time   `json:"createdAt,omitempty"`
	Sender      *User        `json:"sender,omitempty"`
}

type Messages struct {
	Messages []*Message `json:"messages,omitempty"`
	Next     *string    `json:"next,omitempty"`
}

type Pagination struct {
	Cursor string `json:"cursor"`
	Limit  int    `json:"limit"`
}

type Post struct {
	ID          string       `json:"id"`
	Visibility  *Visibility  `json:"visibility,omitempty"`
	Content     string       `json:"content"`
	ContentType *ContentType `json:"contentType,omitempty"`
	CreatedAt   string       `json:"createdAt"`
	Author      *User        `json:"author,omitempty"`
	Likes       *Likes       `json:"likes,omitempty"`
	Comments    *Comments    `json:"comments,omitempty"`
}

type PostCreateInput struct {
	Visibility  *Visibility  `json:"visibility,omitempty"`
	Content     *string      `json:"content,omitempty"`
	ContentType *ContentType `json:"contentType,omitempty"`
}

type Posts struct {
	Posts []*Post `json:"posts"`
	Next  string  `json:"next"`
}

type User struct {
	ID         string    `json:"id"`
	Username   string    `json:"username"`
	Birthday   *Birthday `json:"birthday"`
	Cents      *Cents    `json:"cents"`
	Name       string    `json:"name"`
	Email      *string   `json:"email,omitempty"`
	Bio        *string   `json:"bio,omitempty"`
	Followers  *Users    `json:"followers,omitempty"`
	Posts      *Posts    `json:"posts,omitempty"`
	TotalLikes int       `json:"totalLikes"`
}

type UserUpdateInput struct {
	First *string `json:"first,omitempty"`
	Last  *string `json:"last,omitempty"`
	Email *string `json:"email,omitempty"`
	Bio   *string `json:"bio,omitempty"`
}

type Users struct {
	Users []*User `json:"users"`
	Next  string  `json:"next"`
}

type ContentType string

const (
	ContentTypeText  ContentType = "TEXT"
	ContentTypeImage ContentType = "IMAGE"
	ContentTypeVideo ContentType = "VIDEO"
)

var AllContentType = []ContentType{
	ContentTypeText,
	ContentTypeImage,
	ContentTypeVideo,
}

func (e ContentType) IsValid() bool {
	switch e {
	case ContentTypeText, ContentTypeImage, ContentTypeVideo:
		return true
	}
	return false
}

func (e ContentType) String() string {
	return string(e)
}

func (e *ContentType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ContentType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ContentType", str)
	}
	return nil
}

func (e ContentType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type Visibility string

const (
	VisibilityPublic  Visibility = "PUBLIC"
	VisibilityFriends Visibility = "FRIENDS"
	VisibilityPrivate Visibility = "PRIVATE"
)

var AllVisibility = []Visibility{
	VisibilityPublic,
	VisibilityFriends,
	VisibilityPrivate,
}

func (e Visibility) IsValid() bool {
	switch e {
	case VisibilityPublic, VisibilityFriends, VisibilityPrivate:
		return true
	}
	return false
}

func (e Visibility) String() string {
	return string(e)
}

func (e *Visibility) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = Visibility(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid Visibility", str)
	}
	return nil
}

func (e Visibility) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}
